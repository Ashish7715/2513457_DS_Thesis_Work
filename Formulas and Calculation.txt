================================================================================
GaWC WORLD CITY HIERARCHY ANALYSIS - FORMULAS AND CALCULATIONS
================================================================================

1. GROWTH METRICS
-----------------

1.1 Compound Annual Growth Rate (CAGR)
    growth_rate = ((end_gnc / start_gnc) ** (1/years_span) - 1) * 100
    
    Where:
    - end_gnc = Global Network Connectivity at end year
    - start_gnc = Global Network Connectivity at start year
    - years_span = Number of years between measurements

1.2 Volatility Calculation
    volatility = gnc_changes.std() * 100
    
    Where:
    - gnc_changes = year-on-year percentage changes
    - std() = standard deviation function

1.3 Stability Score
    stability_score = 1 / (1 + np.std(changes))
    
    Where:
    - Higher score indicates more stable growth pattern
    - changes = array of period-to-period changes


2. CONCENTRATION METRICS
------------------------

2.1 Herfindahl-Hirschman Index (HHI)
    shares = [v/total_value for v in sector_totals.values()]
    hhi = sum(s**2 for s in shares) * 10000
    
    Where:
    - sector_totals = service values by sector
    - Scale: 0-10000 (higher = more concentrated)
    - <1500 = Low concentration
    - 1500-2500 = Moderate concentration
    - >2500 = High concentration


3. NETWORK CENTRALITY METRICS
-----------------------------

3.1 Degree Centrality
    degree_centrality = nx.degree_centrality(G)
    
    Formula: DC(i) = d(i) / (n-1)
    Where:
    - d(i) = degree of node i
    - n = total number of nodes

3.2 Betweenness Centrality
    betweenness_centrality = nx.betweenness_centrality(G, weight='weight')
    
    Formula: BC(v) = Σ(σ(s,t|v) / σ(s,t))
    Where:
    - σ(s,t) = number of shortest paths from s to t
    - σ(s,t|v) = number of shortest paths from s to t through v

3.3 Eigenvector Centrality
    eigenvector_centrality = nx.eigenvector_centrality(G, weight='weight')
    
    Formula: x(i) = (1/λ) * Σ(A(i,j) * x(j))
    Where:
    - λ = largest eigenvalue
    - A = adjacency matrix
    - Measures influence based on connections to influential nodes

3.4 Clustering Coefficient
    clustering = nx.clustering(G, weight='weight')
    
    Formula: C(i) = 2 * |e(i)| / (k(i) * (k(i)-1))
    Where:
    - e(i) = number of edges between neighbors of i
    - k(i) = degree of node i


4. CONNECTIVITY METRICS
-----------------------

4.1 Relative GNC
    gnc_rel = (gnc_abs / max_gnc * 100)
    
    Where:
    - gnc_abs = absolute GNC value
    - max_gnc = maximum GNC in the dataset (usually London)
    - Result: percentage relative to top city

4.2 Regional Connectivity Weight
    region_weight = Σ(G[city][region_city]['weight'])
    
    Where:
    - Sum of all edge weights to cities in a specific region

4.3 Total Connectivity
    total_connectivity = Σ(all regional weights)


5. GATEWAY METRICS
------------------

5.1 Gateway Balance Score (Entropy-based)
    proportions = [r['weight']/total_weight for r in regional_connectivity.values()]
    entropy = -sum(p * np.log(p) if p > 0 else 0 for p in proportions)
    max_entropy = -np.log(1/len(regions))
    balance_score = entropy / max_entropy
    
    Where:
    - Normalized 0-1 (1 = perfectly balanced)
    - Based on Shannon entropy
    - Measures distribution across regions


6. HEADQUARTERS STRATEGY METRICS
--------------------------------

6.1 Headquarters Concentration Ratio
    hq_ratio = hq_count / total_offices
    
    Where:
    - hq_count = number of offices with service value ≥ 4
    - total_offices = all offices with service value > 0

6.2 Office Classification
    Global HQ: service_value ≥ 4
    Regional HQ: service_value = 3
    Branch Office: 0 < service_value < 3

6.3 Average Office Value
    avg_office_value = city_data[city_data > 0].mean()
    
    Where:
    - Only considers firms with presence (value > 0)


7. COMPETITIVE DYNAMICS
-----------------------

7.1 Jaccard Similarity Index
    jaccard = intersection / union
    
    Where:
    - intersection = firms present in both cities
    - union = firms present in either city
    - Range: 0-1 (1 = identical firm portfolios)

7.2 Complementarity Score
    complementarity = unique_to_city2 / total_firms_city2
    
    Where:
    - unique_to_city2 = firms in city2 not in city1
    - Measures unique value proposition


8. RANKING METRICS
------------------

8.1 Rank Change
    rank_improvement = start_rank - end_rank
    
    Where:
    - Positive = improvement (moving up)
    - Negative = decline (moving down)

8.2 Rank Assignment
    rank = GNC_abs.rank(ascending=False, method='min')
    
    Where:
    - Higher GNC = lower rank number (1 = best)


9. CHANGE METRICS
-----------------

9.1 Year-on-Year Change Rate
    change_rate = (after_value - before_value) / before_value * 100

9.2 Period Growth Rate
    period_growth = ((value_end / value_start) - 1) * 100

9.3 Mean Change
    mean_change = np.mean(period_changes)


10. SERVICE VALUE SCALE (Taylor 2001)
-------------------------------------

Service Values:
    0 = No presence
    1 = Minimal presence (no partners/small office)
    2 = Normal presence (typical office)
    3 = Large presence (large office)
    4 = Regional HQ functions
    5 = Global HQ

Total Service Value for a city:
    TSV = Σ(service_values across all firms)


11. BIPARTITE NETWORK PROJECTION
--------------------------------

11.1 Weighted Projection
    G = nx.bipartite.weighted_projected_graph(B, city_nodes)
    
    Where:
    - B = bipartite graph (cities + firms)
    - Projects to city-only network
    - Edge weight = shared firms between cities


12. PREDICTIVE MODEL METRICS
----------------------------

12.1 R-squared Score
    r2 = 1 - (SS_res / SS_tot)
    
    Where:
    - SS_res = Σ(y_true - y_pred)²
    - SS_tot = Σ(y_true - y_mean)²

12.2 Mean Squared Error
    mse = mean((y_true - y_pred)²)

12.3 Cross-Validation Score
    cv_scores = cross_val_score(model, X, y, cv=5, scoring='r2')
    
    Where:
    - cv=5 indicates 5-fold cross-validation


13. TEMPORAL DYNAMICS
---------------------

13.1 Maximum Increase
    max_increase = np.max(period_changes)

13.2 Maximum Decrease
    max_decrease = np.min(period_changes)

13.3 Coefficient of Variation
    cv = (std_deviation / mean) * 100
    
    Where:
    - Measures relative variability


14. COMMUNITY DETECTION
-----------------------

14.1 Louvain Modularity
    communities = community_louvain.best_partition(G, weight='weight')
    
    Modularity Q = (1/2m) * Σ[A_ij - (k_i*k_j/2m)] * δ(c_i, c_j)
    
    Where:
    - A_ij = adjacency matrix
    - k_i = degree of node i
    - m = total edge weight
    - δ(c_i, c_j) = 1 if nodes in same community, 0 otherwise


15. DATA NORMALIZATION
----------------------

15.1 Feature Scaling (StandardScaler)
    z = (x - μ) / σ
    
    Where:
    - x = original value
    - μ = mean
    - σ = standard deviation

15.2 Min-Max Normalization
    normalized = (value - min) / (max - min)


16. FIRM DYNAMICS
-----------------

16.1 Entry Rate
    entries = count(firms with value_t=0 and value_t+1>0)

16.2 Exit Rate
    exits = count(firms with value_t>0 and value_t+1=0)

16.3 Upgrade Rate
    upgrades = count(firms with value_t+1 > value_t)

16.4 Downgrade Rate
    downgrades = count(firms with value_t+1 < value_t)


17. POLICY IMPACT ANALYSIS
--------------------------

17.1 GNC Change Rate (Event Impact)
    impact = (after_gnc - before_gnc) / before_gnc * 100
    
    Where:
    - before_gnc = GNC before policy event
    - after_gnc = GNC after policy event


================================================================================
NOTES ON USAGE
================================================================================

1. All percentage calculations are multiplied by 100 for readability
2. Network metrics use NetworkX library implementations
3. Service values follow Taylor's (2001) World City Network specification
4. Statistical functions use NumPy/SciPy implementations
5. Machine learning uses scikit-learn implementations
6. Graph algorithms follow standard network science definitions

================================================================================